!SESSION 2020-03-04 18:19:45.179 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-04 18:20:40.072
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2020-03-04 18:21:25.822
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2020-03-04 18:21:25.822
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.822
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.822
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'osgi.bundle; org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.822
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.822
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.822
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.ajde [1.7.3.20130613144500-a,1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.822
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.822
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.822
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.feature.group [1.7.3.20130613144500-a,1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2020-03-04 18:21:25.834
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2020-03-04 18:21:25.834
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.834
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.834
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'osgi.bundle; org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.834
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.834
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.834
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.ajde [1.7.3.20130613144500-a,1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.834
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.834
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.834
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.feature.group [1.7.3.20130613144500-a,1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2020-03-04 18:21:25.855
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2020-03-04 18:21:25.855
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.855
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.855
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'osgi.bundle; org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.855
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.855
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.855
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.ajde [1.7.3.20130613144500-a,1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.855
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.855
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.855
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.feature.group [1.7.3.20130613144500-a,1.7.3.20130613144500-a]

!ENTRY org.eclipse.equinox.p2.operations 4 10053 2020-03-04 18:21:25.859
!MESSAGE Operation details
!SUBENTRY 1 org.eclipse.equinox.p2.director 4 10053 2020-03-04 18:21:25.859
!MESSAGE Cannot complete the install because one or more required items could not be found.
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.859
!MESSAGE Software being installed: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.859
!MESSAGE Missing requirement: AspectJ 1.7.3.20130613144500-a (org.aspectj.ajde 1.7.3.20130613144500-a) requires 'osgi.bundle; org.eclipse.core.runtime.compatibility 0.0.0' but it could not be found
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.859
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.860
!MESSAGE From: AspectJ Compiler 1.7.3.20130613144500-a (org.aspectj.feature.group 1.7.3.20130613144500-a)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.860
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.ajde [1.7.3.20130613144500-a,1.7.3.20130613144500-a]
!SUBENTRY 2 org.eclipse.equinox.p2.director 4 1 2020-03-04 18:21:25.860
!MESSAGE Cannot satisfy dependency:
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.860
!MESSAGE From: AspectJ Development Tools 2.2.3.e43x-RELEASE-20130627-0800 (org.eclipse.ajdt.feature.group 2.2.3.e43x-RELEASE-20130627-0800)
!SUBENTRY 3 org.eclipse.equinox.p2.director 4 0 2020-03-04 18:21:25.860
!MESSAGE To: org.eclipse.equinox.p2.iu; org.aspectj.feature.group [1.7.3.20130613144500-a,1.7.3.20130613144500-a]
!SESSION 2020-03-04 18:21:57.400 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US

!ENTRY org.eclipse.osgi 4 0 2020-03-04 18:21:57.644
!MESSAGE error loading hook: org.eclipse.equinox.weaving.hooks.WeavingHook
!STACK 0
java.lang.NoClassDefFoundError: org/eclipse/osgi/baseadaptor/HookConfigurator
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016)
	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:151)
	at java.base/java.net.URLClassLoader.defineClass(URLClassLoader.java:515)
	at java.base/java.net.URLClassLoader$1.run(URLClassLoader.java:423)
	at java.base/java.net.URLClassLoader$1.run(URLClassLoader.java:417)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:691)
	at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:416)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:588)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016)
	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:151)
	at java.base/java.net.URLClassLoader.defineClass(URLClassLoader.java:515)
	at java.base/java.net.URLClassLoader$1.run(URLClassLoader.java:423)
	at java.base/java.net.URLClassLoader$1.run(URLClassLoader.java:417)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:691)
	at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:416)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:588)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:333)
	at org.eclipse.osgi.internal.hookregistry.HookRegistry.loadConfigurators(HookRegistry.java:200)
	at org.eclipse.osgi.internal.hookregistry.HookRegistry.initialize(HookRegistry.java:115)
	at org.eclipse.osgi.internal.framework.EquinoxContainer.<init>(EquinoxContainer.java:80)
	at org.eclipse.osgi.launch.Equinox.<init>(Equinox.java:34)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.startup(EclipseStarter.java:315)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:251)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
Caused by: java.lang.ClassNotFoundException: org.eclipse.osgi.baseadaptor.HookConfigurator
	at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:436)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:588)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	... 35 more

!ENTRY org.eclipse.egit.ui 2 0 2020-03-04 18:22:06.215
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-04 18:24:29.878 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data file:/C:/Users/karp09/eclipse-workspace/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-04 18:24:43.840
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-09 17:46:58.901 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-03-09 17:47:16.335
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-03-09 17:47:34.354
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-13 20:48:30.608 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-03-13 20:59:25.750
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-03-13 20:59:45.515
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2020-03-13 21:21:30.178
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.debug.internal.ui.sourcelookup.Prompter$$Lambda$901/0x0000000801b6a440@4be09498, thread Worker-31: Launching TestAspects (1) will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2020-03-13 21:21:30.178
!MESSAGE Worker-31: Launching TestAspects (1) thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread Worker-31: Launching TestAspects (1)
	at java.management@13.0.2/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@13.0.2/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:466)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:209)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:179)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:155)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4622)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.handleStatus(Prompter.java:81)
	at org.eclipse.debug.core.model.LaunchConfigurationDelegate.saveBeforeLaunch(LaunchConfigurationDelegate.java:246)
	at org.eclipse.debug.core.model.LaunchConfigurationDelegate.preLaunchCheck(LaunchConfigurationDelegate.java:198)
	at org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.preLaunchCheck(AbstractJavaLaunchConfigurationDelegate.java:1020)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:823)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:719)
	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1017)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$2.run(DebugUIPlugin.java:1220)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.ui 4 4 2020-03-13 21:21:30.178
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at java.base@13.0.2/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:318)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:205)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:297)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2243)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2290)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2322)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5052)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1275)
	at org.eclipse.ajdt.internal.ui.editor.AspectJEditor.doSave(AspectJEditor.java:297)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7182)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:850)
	at org.eclipse.ui.internal.SaveablesList$$Lambda$903/0x0000000801ba0c40.run(Unknown Source)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.ui.internal.SaveableHelper$$Lambda$904/0x0000000801ba1040.run(Unknown Source)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:2368)
	at org.eclipse.ui.internal.WorkbenchWindow$$Lambda$731/0x0000000801990c40.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2366)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:858)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:822)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3451)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1495)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1483)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter$$Lambda$901/0x0000000801b6a440.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.ui.internal.UISynchronizer.lambda$0(UISynchronizer.java:152)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$664/0x00000008017a5040.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.ui.internal.Workbench$$Lambda$190/0x0000000800e2d840.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@13.0.2/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@13.0.2/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base@13.0.2/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@13.0.2/java.lang.reflect.Method.invoke(Method.java:567)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.core 4 1005 2020-03-13 21:24:20.996
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-13 21:24:21.007
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-13 21:24:21.008
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-13 21:24:21.008
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2020-03-13 21:24:21.023
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-13 21:24:21.023
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 333);
		//myBank.generateReport();
		
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(4000, 300);
		myBank.generateReport();

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public aspect MyAspects {
/** 
 * 2. An aspect to log the start and end of every money transfer.
 * 
 */
	pointcut manageTransfer(Bank s, int sourceID, int targetID, double amount):
		execution (public void transfer(int,int,double)) 
			&& target(s)
				&& args(sourceID, targetID, amount);

	before (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("about to make a money transfer") ;
	}
	
	after (Bank s, int sourceID, int targetID, double amount):
		manageTransfer(s, sourceID, targetID, amount){ System.out.println("money transfer complete.") ;
	}
 
 
	/**
	 * An aspect to log each call to the deposit method every time the money transfer method executes.
	 */
	
	pointcut transferDeposit(Account s, double amount):
			withincode(public void transfer(int, int, double))
				&& call(public boolean deposit(double))
					&& target(s)
						&& args(amount);
	
	before(Account s, double amount):
		transferDeposit(s,amount){
			System.out.println("shalambaba About to transfer " + amount + " into account #" + s.getId());
		}
		
	
	/**
	 * An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
	 */
	
	pointcut CallDeposit (Account s, double amount):
		call(public boolean deposit(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallDeposit(s, amount){
		System.out.println("About to deposit");
	}


	?
	pointcut CallWithdraw (Account s, double amount):
		call(public boolean withdraw(double))
			&& target(s)
				&& args(amount);
	
	before (Account s, double amount):
		CallWithdraw (s, amount){
		System.out.println("About to withdraw");
	}
}
		
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeSingleMemberAnnotation(AJSourceElementParser2.java:578)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6546)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jface.text 4 0 2020-03-13 22:05:12.138
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException: class org.eclipse.ajdt.core.javaelements.AdviceElementInfo cannot be cast to class org.eclipse.jdt.internal.core.SourceMethodInfo (org.eclipse.ajdt.core.javaelements.AdviceElementInfo is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @544f6a62; org.eclipse.jdt.internal.core.SourceMethodInfo is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @11435517)
	at org.eclipse.ajdt.core.javaelements.AspectJMemberElement.getDefaultValue(AspectJMemberElement.java:324)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotationMemberDefaultValue(JavadocHover.java:857)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:833)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2020-03-13 22:14:38.994
!MESSAGE 
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.core.AbstractClassFile.getClassFileContent(AbstractClassFile.java:213)
	at org.eclipse.jdt.internal.core.ModularClassFile.getJarBinaryModuleInfo(ModularClassFile.java:171)
	at org.eclipse.jdt.internal.core.ModularClassFile.getBinaryModuleInfo(ModularClassFile.java:136)
	at org.eclipse.jdt.internal.core.ModularClassFile.buildStructure(ModularClassFile.java:55)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.ModularClassFile.getModule(ModularClassFile.java:298)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getSourceModuleDescription(PackageFragmentRoot.java:914)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getModuleDescription(PackageFragmentRoot.java:890)
	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.getModuleDescription(JarPackageFragmentRoot.java:321)
	at org.eclipse.jdt.internal.core.NameLookup.getModuleDescription(NameLookup.java:911)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModuleDescription(SearchableEnvironment.java:987)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModulesDeclaringPackage(SearchableEnvironment.java:926)
	at org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment.getUniqueModulesDeclaringPackage(IModuleAwareNameEnvironment.java:113)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getVisiblePackage(ModuleBinding.java:583)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getTopLevelPackage(ModuleBinding.java:552)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTopLevelPackage(LookupEnvironment.java:1652)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.getDefaultImports(CompilationUnitScope.java:681)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkAndSetImports(CompilationUnitScope.java:225)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:583)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1063)
	at org.eclipse.ajdt.core.text.ITDCodeSelection.findJavaElement(ITDCodeSelection.java:71)
	at org.eclipse.ajdt.internal.core.contentassist.ContentAssistProvider.doCodeSelect(ContentAssistProvider.java:164)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$6$3f3ffce8(ITDAwarenessAspect.aj:317)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:124)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:674)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-13 23:55:07.134
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NoSuchMethodError: 'void org.eclipse.jdt.internal.ui.text.correction.ReorgCorrectionsSubProcessor.importNotFoundProposals(org.eclipse.jdt.ui.text.java.IInvocationContext, org.eclipse.jdt.ui.text.java.IProblemLocation, java.util.Collection)'
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.process(QuickFixProcessor.java:271)
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.getCorrections(QuickFixProcessor.java:247)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:387)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:347)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:342)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:477)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:105)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:307)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:192)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:251)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$0(TextViewerHoverManager.java:241)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-13 23:55:10.196
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NoSuchMethodError: 'void org.eclipse.jdt.internal.ui.text.correction.ReorgCorrectionsSubProcessor.importNotFoundProposals(org.eclipse.jdt.ui.text.java.IInvocationContext, org.eclipse.jdt.ui.text.java.IProblemLocation, java.util.Collection)'
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.process(QuickFixProcessor.java:271)
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.getCorrections(QuickFixProcessor.java:247)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:387)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:347)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:342)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:477)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:105)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:307)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:192)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:251)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$0(TextViewerHoverManager.java:241)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-13 23:55:17.737
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NoSuchMethodError: 'void org.eclipse.jdt.internal.ui.text.correction.ReorgCorrectionsSubProcessor.importNotFoundProposals(org.eclipse.jdt.ui.text.java.IInvocationContext, org.eclipse.jdt.ui.text.java.IProblemLocation, java.util.Collection)'
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.process(QuickFixProcessor.java:271)
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.getCorrections(QuickFixProcessor.java:247)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:387)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:347)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:342)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:477)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:105)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:307)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:192)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:251)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$0(TextViewerHoverManager.java:241)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-13 23:55:21.412
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NoSuchMethodError: 'void org.eclipse.jdt.internal.ui.text.correction.ReorgCorrectionsSubProcessor.importNotFoundProposals(org.eclipse.jdt.ui.text.java.IInvocationContext, org.eclipse.jdt.ui.text.java.IProblemLocation, java.util.Collection)'
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.process(QuickFixProcessor.java:271)
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.getCorrections(QuickFixProcessor.java:247)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:387)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:347)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:342)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:477)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:105)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:307)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:192)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:251)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$0(TextViewerHoverManager.java:241)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-13 23:55:25.757
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NoSuchMethodError: 'void org.eclipse.jdt.internal.ui.text.correction.ReorgCorrectionsSubProcessor.importNotFoundProposals(org.eclipse.jdt.ui.text.java.IInvocationContext, org.eclipse.jdt.ui.text.java.IProblemLocation, java.util.Collection)'
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.process(QuickFixProcessor.java:271)
	at org.eclipse.ajdt.internal.ui.editor.quickfix.QuickFixProcessor.getCorrections(QuickFixProcessor.java:247)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:387)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:347)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:342)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:477)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:105)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:307)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:192)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:251)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$0(TextViewerHoverManager.java:241)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jface.text 2 0 2020-03-14 00:10:04.006
!MESSAGE 
!STACK 0
java.lang.ClassCastException: class org.eclipse.ajdt.core.javaelements.PointcutElementInfo cannot be cast to class org.eclipse.jdt.internal.core.SourceMethodInfo (org.eclipse.ajdt.core.javaelements.PointcutElementInfo is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @544f6a62; org.eclipse.jdt.internal.core.SourceMethodInfo is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @11435517)
	at org.eclipse.ajdt.core.javaelements.AspectJMemberElement.getDefaultValue(AspectJMemberElement.java:324)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotationMemberDefaultValue(JavadocHover.java:857)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.addConstantOrDefaultValue(AbstractJavaCompletionProposal.java:654)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:599)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2020-03-14 17:04:11.219 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-14 17:04:56.723
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-16 13:38:09.679 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-16 13:38:42.746
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2020-03-16 16:04:41.010
!MESSAGE 
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.core.AbstractClassFile.getClassFileContent(AbstractClassFile.java:213)
	at org.eclipse.jdt.internal.core.ModularClassFile.getJarBinaryModuleInfo(ModularClassFile.java:171)
	at org.eclipse.jdt.internal.core.ModularClassFile.getBinaryModuleInfo(ModularClassFile.java:136)
	at org.eclipse.jdt.internal.core.ModularClassFile.buildStructure(ModularClassFile.java:55)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.ModularClassFile.getModule(ModularClassFile.java:298)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getSourceModuleDescription(PackageFragmentRoot.java:914)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getModuleDescription(PackageFragmentRoot.java:890)
	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.getModuleDescription(JarPackageFragmentRoot.java:321)
	at org.eclipse.jdt.internal.core.NameLookup.getModuleDescription(NameLookup.java:911)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModuleDescription(SearchableEnvironment.java:987)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModulesDeclaringPackage(SearchableEnvironment.java:926)
	at org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment.getUniqueModulesDeclaringPackage(IModuleAwareNameEnvironment.java:113)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getVisiblePackage(ModuleBinding.java:583)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getTopLevelPackage(ModuleBinding.java:552)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTopLevelPackage(LookupEnvironment.java:1652)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.getDefaultImports(CompilationUnitScope.java:681)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkAndSetImports(CompilationUnitScope.java:240)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:583)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1063)
	at org.eclipse.ajdt.core.text.ITDCodeSelection.findJavaElement(ITDCodeSelection.java:71)
	at org.eclipse.ajdt.internal.core.contentassist.ContentAssistProvider.doCodeSelect(ContentAssistProvider.java:164)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$6$3f3ffce8(ITDAwarenessAspect.aj:317)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:124)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2020-03-16 16:08:58.626
!MESSAGE 
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.core.AbstractClassFile.getClassFileContent(AbstractClassFile.java:213)
	at org.eclipse.jdt.internal.core.ModularClassFile.getJarBinaryModuleInfo(ModularClassFile.java:171)
	at org.eclipse.jdt.internal.core.ModularClassFile.getBinaryModuleInfo(ModularClassFile.java:136)
	at org.eclipse.jdt.internal.core.ModularClassFile.buildStructure(ModularClassFile.java:55)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.ModularClassFile.getModule(ModularClassFile.java:298)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getSourceModuleDescription(PackageFragmentRoot.java:914)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getModuleDescription(PackageFragmentRoot.java:890)
	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.getModuleDescription(JarPackageFragmentRoot.java:321)
	at org.eclipse.jdt.internal.core.NameLookup.getModuleDescription(NameLookup.java:911)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModuleDescription(SearchableEnvironment.java:987)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModulesDeclaringPackage(SearchableEnvironment.java:926)
	at org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment.getUniqueModulesDeclaringPackage(IModuleAwareNameEnvironment.java:113)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getVisiblePackage(ModuleBinding.java:583)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getTopLevelPackage(ModuleBinding.java:552)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTopLevelPackage(LookupEnvironment.java:1652)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.getDefaultImports(CompilationUnitScope.java:681)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkAndSetImports(CompilationUnitScope.java:240)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:583)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1063)
	at org.eclipse.ajdt.core.text.ITDCodeSelection.findJavaElement(ITDCodeSelection.java:71)
	at org.eclipse.ajdt.internal.core.contentassist.ContentAssistProvider.doCodeSelect(ContentAssistProvider.java:164)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$6$3f3ffce8(ITDAwarenessAspect.aj:317)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:124)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:674)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2020-03-16 16:16:34.003
!MESSAGE 
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.core.AbstractClassFile.getClassFileContent(AbstractClassFile.java:213)
	at org.eclipse.jdt.internal.core.ModularClassFile.getJarBinaryModuleInfo(ModularClassFile.java:171)
	at org.eclipse.jdt.internal.core.ModularClassFile.getBinaryModuleInfo(ModularClassFile.java:136)
	at org.eclipse.jdt.internal.core.ModularClassFile.buildStructure(ModularClassFile.java:55)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.ModularClassFile.getModule(ModularClassFile.java:298)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getSourceModuleDescription(PackageFragmentRoot.java:914)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getModuleDescription(PackageFragmentRoot.java:890)
	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.getModuleDescription(JarPackageFragmentRoot.java:321)
	at org.eclipse.jdt.internal.core.NameLookup.getModuleDescription(NameLookup.java:911)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModuleDescription(SearchableEnvironment.java:987)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModulesDeclaringPackage(SearchableEnvironment.java:926)
	at org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment.getUniqueModulesDeclaringPackage(IModuleAwareNameEnvironment.java:113)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getVisiblePackage(ModuleBinding.java:583)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getTopLevelPackage(ModuleBinding.java:552)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTopLevelPackage(LookupEnvironment.java:1652)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.getDefaultImports(CompilationUnitScope.java:681)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkAndSetImports(CompilationUnitScope.java:240)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:583)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1063)
	at org.eclipse.ajdt.core.text.ITDCodeSelection.findJavaElement(ITDCodeSelection.java:71)
	at org.eclipse.ajdt.internal.core.contentassist.ContentAssistProvider.doCodeSelect(ContentAssistProvider.java:164)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$6$3f3ffce8(ITDAwarenessAspect.aj:317)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:124)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:674)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2020-03-16 16:17:16.836
!MESSAGE 
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.core.AbstractClassFile.getClassFileContent(AbstractClassFile.java:213)
	at org.eclipse.jdt.internal.core.ModularClassFile.getJarBinaryModuleInfo(ModularClassFile.java:171)
	at org.eclipse.jdt.internal.core.ModularClassFile.getBinaryModuleInfo(ModularClassFile.java:136)
	at org.eclipse.jdt.internal.core.ModularClassFile.buildStructure(ModularClassFile.java:55)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.ModularClassFile.getModule(ModularClassFile.java:298)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getSourceModuleDescription(PackageFragmentRoot.java:914)
	at org.eclipse.jdt.internal.core.PackageFragmentRoot.getModuleDescription(PackageFragmentRoot.java:890)
	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.getModuleDescription(JarPackageFragmentRoot.java:321)
	at org.eclipse.jdt.internal.core.NameLookup.getModuleDescription(NameLookup.java:911)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModuleDescription(SearchableEnvironment.java:987)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.getModulesDeclaringPackage(SearchableEnvironment.java:926)
	at org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment.getUniqueModulesDeclaringPackage(IModuleAwareNameEnvironment.java:113)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getVisiblePackage(ModuleBinding.java:583)
	at org.eclipse.jdt.internal.compiler.lookup.ModuleBinding.getTopLevelPackage(ModuleBinding.java:552)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTopLevelPackage(LookupEnvironment.java:1652)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.getDefaultImports(CompilationUnitScope.java:681)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkAndSetImports(CompilationUnitScope.java:240)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:583)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1063)
	at org.eclipse.ajdt.core.text.ITDCodeSelection.findJavaElement(ITDCodeSelection.java:71)
	at org.eclipse.ajdt.internal.core.contentassist.ContentAssistProvider.doCodeSelect(ContentAssistProvider.java:164)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$6$3f3ffce8(ITDAwarenessAspect.aj:317)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:124)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:674)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)

!ENTRY org.eclipse.jface.text 4 0 2020-03-16 16:19:03.712
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException: class org.eclipse.ajdt.core.javaelements.PointcutElementInfo cannot be cast to class org.eclipse.jdt.internal.core.SourceMethodInfo (org.eclipse.ajdt.core.javaelements.PointcutElementInfo is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @1c00a9f0; org.eclipse.jdt.internal.core.SourceMethodInfo is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @3e5febe9)
	at org.eclipse.ajdt.core.javaelements.AspectJMemberElement.getDefaultValue(AspectJMemberElement.java:324)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotationMemberDefaultValue(JavadocHover.java:857)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:833)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)
!SESSION 2020-03-18 14:12:33.391 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-18 14:13:03.337
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-18 14:53:04.200 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-18 14:53:37.585
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-18 20:12:04.797 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-18 20:12:20.117
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-22 19:09:13.447 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-22 19:10:31.118
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-22 19:12:55.569 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/C:/Users/karp09/eclipse-workspace/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-22 19:13:05.327
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-22 20:28:12.154 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-22 20:28:23.474
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-23 17:08:46.201 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-03-23 17:09:17.875
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-03-25 12:57:52.118 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=13.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-03-25 12:58:05.265
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-03-25 12:58:21.751
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\karp09'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2020-03-25 13:07:41.959
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.TreeLineTracker.fail(TreeLineTracker.java:1054)
	at org.eclipse.jface.text.TreeLineTracker.lineByOffset(TreeLineTracker.java:268)
	at org.eclipse.jface.text.TreeLineTracker.getLineNumberOfOffset(TreeLineTracker.java:1122)
	at org.eclipse.jface.text.AbstractLineTracker.getLineNumberOfOffset(AbstractLineTracker.java:154)
	at org.eclipse.jface.text.AbstractDocument.getLineOfOffset(AbstractDocument.java:871)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.getLineOfOffset(SynchronizableDocument.java:334)
	at org.eclipse.jdt.internal.ui.text.java.JavaAutoIndentStrategy.smartIndentAfterClosingBracket(JavaAutoIndentStrategy.java:226)
	at org.eclipse.jdt.internal.ui.text.java.JavaAutoIndentStrategy.smartIndentOnKeypress(JavaAutoIndentStrategy.java:1127)
	at org.eclipse.jdt.internal.ui.text.java.JavaAutoIndentStrategy.customizeDocumentCommand(JavaAutoIndentStrategy.java:1255)
	at org.eclipse.jface.text.TextViewer.customizeDocumentCommand(TextViewer.java:3606)
	at org.eclipse.jface.text.TextViewer.handleVerifyEvent(TextViewer.java:3636)
	at org.eclipse.jface.text.source.projection.ProjectionViewer.handleVerifyEvent(ProjectionViewer.java:1248)
	at org.eclipse.jface.text.TextViewer$TextVerifyListener.verifyText(TextViewer.java:426)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:277)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:780)
	at org.eclipse.swt.custom.StyledText.modifyContent(StyledText.java:7402)
	at org.eclipse.swt.custom.StyledText.sendKeyEvent(StyledText.java:8311)
	at org.eclipse.swt.custom.StyledText.doContent(StyledText.java:2512)
	at org.eclipse.swt.custom.StyledText.handleKey(StyledText.java:6075)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6106)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5795)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1491)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4879)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:353)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4761)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.core 4 1005 2020-03-25 13:42:40.115
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-25 13:42:40.128
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-25 13:42:40.129
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-25 13:42:40.129
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2020-03-25 13:42:40.142
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-25 13:42:40.143
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.core 4 1005 2020-03-25 13:42:41.162
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 2 2020-03-25 13:42:41.179
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-25 13:42:41.180
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-25 13:42:41.180
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.ui 4 0 2020-03-25 13:42:41.200
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 17 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2020-03-25 13:42:41.200
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeMarkerAnnotation(AJSourceElementParser2.java:450)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6542)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more

!ENTRY org.eclipse.jdt.core 4 1005 2020-03-25 13:42:43.228
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id()
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id()
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id()
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;

public class TestAspects {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Bank myBank = new Bank("Devon's Bank", 1234567);
		myBank.addClient("Devon M.", 4000);
		myBank.addClient("Ann M.", 500);
		myBank.addClient("Mary B.", 644);
		myBank.addClient("Jack T.", 744);
		myBank.addClient("Harry O.", 844);
		myBank.addClient("Brian M.", 944);
		myBank.addClient("Hensley H.", 1444);
		myBank.addClient("Nora N.", 2444);
		myBank.deposit(1235, 111);
		myBank.deposit(1235, 33333);
		myBank.generateReport();
		//myBank.deleteClient(1235);
		myBank.transfer(1235, 1236, 100);
		myBank.withdraw(1242, 300);
		myBank.deleteClient(1242);
		myBank.transfer(1235, 1236, 100);
		myBank.transfer(1235, 1236, 10000);

		

	}// end main(...)

}//end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
//	Client's bank account

public class Account {
	String fname, lname;
	int id;
	private double balance;
	
	public Account (String fname, String lname, int id, double balance){
		this.fname = fname;
	    this.lname = lname;
	    this.id = id;
	    this.balance = balance;
	    
	    
	}

	public Account (String name, int id, double balance){
		String[] aName = name.split(" ");
		this.fname = aName[0];
		String myLname = "";
		for (int i=1; i<aName.length; i++) {
	         myLname += aName[i] + " ";
	    }
	    this.lname = myLname;
	    this.id = id;
	    this.balance = balance;
	}

    public boolean deposit(double amount){
    	this.balance += amount;
    	System.out.println("$" + amount + " added to account " + this.id + ".");
	    return true;
	}

	public boolean withdraw(double amount){
		if(amount < this.balance){
			this.balance -= amount;
			System.out.println("$" + amount + " withdrawn from account " + this.id + ".");
	        return true;
		}
	    else
	    	System.out.println("\nNot enough money to withdraw " + amount + " dollars.");
	        return false;
	}
	
	public double getBalance(){
		return this.balance;
	}
	
	public String getName(){
		return this.fname + " " + this.lname;
	}
	
	public int getId(){
		return this.id;
	}
	

}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

public aspect MyAspects {

//	/**
//	 * 1. An aspect to log each call to the deposit method every time the deposit method is called regardless of the calling context.
//	 */
//	
//	pointcut CallDeposit (Account s, double amount):
//		call(public boolean deposit(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallDeposit(s, amount){
//		System.out.println("About to deposit");
//	}
//
//
//	/**
//	 *
//	 * 2.  an aspect to log each execution to the withdraw method
//	 * 
//	 */
//	pointcut CallWithdraw (Account s, double amount):
//		execution(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	before (Account s, double amount):
//		CallWithdraw (s, amount){
//		System.out.println("About to withdraw");
//	}
//	/**
//	 *3. an aspect to avoid execution of the deleteClient method and to deposit money into the client's account instead
//	 */
//	pointcut cancelDelete (Bank s,int id):
//		call(public void deleteClient(int))
//			&& target(s)
//				&& args(id);
//			
//			
//	void around(Bank s,int id):
//		cancelDelete(s,id)
//	{
//		System.out.println("cancelled deletion of account");	
//		System.out.println("depositing $500 dollars into account number " + id);
//		s.deposit(id,500);
//	}
//	/**
//	 * 4. an aspect to rather than do the normal withdrawal for each transfer, credit the withdrawal account with the withdrawal amount instead
//	 *
//	*/
//	pointcut creditWithdrawal (Account s, double amount):
//		withincode(public void transfer(int,int,double))
//		&& call(public boolean withdraw(double))
//			&& target(s)
//				&& args(amount);
//	
//	Boolean around (Account s, double amount):
//		creditWithdrawal(s,amount){
//		System.out.println("instead of doing the withdrawal we will deposit the withdrawal amount into the account");
//		System.out.println("about to credit withdrawal account:" + s.getId() + " balance " + s.getBalance() + " with " + amount);
//		s.deposit(amount);
//		return true;
//		
//	}
//	
	/**
	 * 
	 * 5. As aspect that whenever the client makes their first transfer, rather than removing money from their account, their account is credited with 50% of the trasnfer amount instead. This is done with two advices: one around and one after.
	 * 
	 */
	private int Account.transferCount = 0;
	public int Account.getTransferCount(){
		return transferCount;
	}
	pointcut bonusTransfer (Account s, double amount):
		withincode(public void transfer(int,int,double))
		&& call(public boolean withdraw(double))
			&& target(s)
				&& args(amount); 
	
//	/**
//	 * 
//	 * 5a.
//	 */
//	Boolean around (Account s, double amount):
//		bonusTransfer (s,amount){
//		if(s.getTransferCount() == 0) {
//		System.out.println("Since this is your first transfer the bank will credit your account 50% of the amount you were to transfer instead ");
//		double amount2 = (amount / 2);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("Sorry this is the " + s.getTransferCount() + " transfer you have done...No Bonus for you!");
//			proceed(s, amount);
//		}
//		return true;
//	}
//
//
//	/**
//	 * 
//	 * 5b.
//	 */
//	
//	after (Account s, double amount):
//		bonusTransfer(s,amount){
//		if (s.getTransferCount() == 0) {
//			System.out.println("You just made your first transfer....Congratulations! You will be deposited 50% of the amount that you transferred");
//		double amount2 = (amount * 1.5);
//		s.deposit(amount2);
//		s.transferCount ++;
//		}
//		else {
//			s.transferCount ++;
//			System.out.println("You have already gotten your bonus!");
//		}
//	} 
//}	
//	/**
//	 *6.  An aspect to log each time an account balance is changed
//	 */
//	
//	pointcut balanceChange ():
//		within(Account)
//			&& set(private double balance);
//				
//	
//	after():
//		balanceChange(){
//			System.out.println("the account balance has been changed");
//		}
//
	/**
	 * 7. as aspect to log each time a specific client has been changed
	 */
	pointcut balanceChange ():
	within(Account)
		&& set(private double balance);
			

	after():
		balanceChange(){
		if get.id()
			System.out.println("the account balance has been changed");
	}
}
	
//	/**
//	 * 8. An aspect to grant a transfer bonus as follows: 5% for transfer between $100 and $5000, 7.5% for transfer over $5000 but less than $10,000 and 10% for transfers over 10,000.
//	 */
//	
//	pointcut bonusTransfers(Account s, double amount):
//		withincode (public void transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	
//	boolean around(Account s, double amount):
//		bonusTransfers(s,amount){
//		if ((amount >= 1000) && (amount < 5000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 5% for being between $1000 and $5000!");
//			double amount2 = (amount * 1.05);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if ((amount >= 5000) && (amount < 10000)) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 7.5% for being between $5000 and $10000!");
//			double amount2 = (amount * 1.075);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else if (amount >= 10000) {
//			System.out.println("Congratulations! your transfer qualifies for a bonus of 10% for being greater than $10000!");
//			double amount2 = (amount * 1.1);
//			System.out.println(amount2 + " has been deposited into your account!");
//			return proceed(s,amount2);
//		}
//		else {
//			System.out.println("Sorry you do not qualify for a bonus.");
//			return proceed(s,amount);
//		}
//		
//	}
//
//	/**
//	 * 9. This is an aspect to do the following: rather than granting a bonus to first time transfer clients, grant a bonus of 20% for every third money transfer
//	 * 
//	 */
//	
//	pointcut thirdTransferBonus (Account s, double amount):
//		withincode(public void Bank.transfer (int,int,double))
//			&& call(public boolean deposit(double))
//				&& target(s)
//					&& args(amount);
//	
//	boolean around(Account s, double amount):
//		thirdTransferBonus(s,amount){
//		int transferCount = (s.getTransferCount() + 1);
//		if (transferCount % 3 == 0) {
//			System.out.println("this is your third transfer so you get a 20% bonus!");
//			double amount2 = amount * 1.2;
//			System.out.println(s.getId() + " gets a deposit including bonus of ... " + amount2);
//			transferCount = 0;
//			return proceed(s,amount2);
//		}
//		else {
//			return proceed(s,amount);
//		}
// 	}
//}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package cs550;
import java.util.*;

/*
Write a program called Banking.py that stores the names of clients and their
bank balances in two separate lists in corresponding positions. For example
if client_balances contains customer balances and client_database contains
customer names, then if the name for a client is at client_database[k], then
the balance for the customer would be at client_balances[k]. The program
should allow for the following transactions menu{

     1{ Add a new client
     2{ delete a client
     3{ Deposit money
     4{ Withdraw money
     5{ Transfer funds
     6{ Find average customer balance
     7{ Print a report showing customer names and corresponding balances.
     0{ Exit the application
*/

//from Account import Account
//import os.path

public class Bank{
	String bank_name;
	int bankId;
    public ArrayList<Account> client_database;
    int client_count;
    int currentId;
    Scanner keyboard;

    public Bank(String name, int id){
    	//Global variables
        this.bank_name = name;
        this.bankId = id;
        this.client_database = new ArrayList();
        this.client_count = 0;
        this.currentId= 1234;
        keyboard = new Scanner(System.in);
    }

    public String getName(){
        return this.bank_name;
    }
    
    public int getBankId(){
        return this.bankId;
    }
    
    public void insert(Account clientAccount){
        this.client_database.add(clientAccount);
    }

    public int getNextId(){
        int id = this.currentId;
        boolean idExists = true;
        while (idExists == true){
            id += 1;
            int result = this.find(id);
            if(result == -1){
                idExists = false;
            }
        }
        this.currentId = id;
        //System.out.println("Your ID # is: " + id);
        return id;
    }

    public void addClient(String name, double balance){
        int id = this.getNextId();        
        Account newClient = new Account(name, id, balance);
        this.insert(newClient);
        //System.out.println("New account for " + name + " created.");
    }

    public void addClient(){
        int id = this.getNextId();
        System.out.print("Enter name of customer: ");
        String name = keyboard.next();
        
        System.out.print("Enter opening balance: ");
        double bal = keyboard.nextDouble();
        
        Account newClient = new Account(name, id, bal);
        this.insert(newClient);
    }

    public int find(int id){
    	for(int i=0; i<client_database.size(); i++){
    		if(id == ((Account)client_database.get(i)).getId())
    			return i;
    	}
        return -1;
    }
    
    public void deleteClient(int id){
        int position = this.find(id);
        if(position == -1)
        	System.out.println("A record for " + id + " was not found.");
        else{
        	System.out.println("\nThe account for " + id + " found.");
            this.client_database.remove(position);
            System.out.println("Account with ID:" + id + " has been deleted.");
        }
    }


    public boolean deposit(int id, double amount){
        int position = this.find(id);
        if(position == -1){
            System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
            boolean result = ((Account)client_database.get(position)).deposit(amount);
            return result;
        }
    }
            
    public boolean withdraw(int id, double amount){
        int position = this.find(id);
        if(position == -1){
        	System.out.println("An account with id = " + id + " was not found.");
            return false;
        }
        else{
        	boolean result = ((Account)client_database.get(position)).withdraw(amount);
            return result;
        }
    }
            
    public void transfer(int source, int target, double amount){
    	System.out.println("Transferring ...");
        int sourcePos = this.find(source);
        int targetPos = this.find(target);
        if(sourcePos == -1 || targetPos == -1)
        	System.out.println("Invalid transaction ... aborting.");
        else{
        	System.out.println("Transferring $" + amount + " from account " + source + " to account " + target + ".");
        	/*((Account)client_database.get(sourcePos)).withdraw(amount);
        	((Account)client_database.get(targetPos)).deposit(amount);*/
        	Account s1 = (Account)client_database.get(sourcePos);
        	if (s1.withdraw(amount) == true) {
        		Account t1 = (Account)client_database.get(targetPos);
        		t1.deposit(amount);
        	}
        	else
        		System.out.println("There was not enough to withdraw in order to finish the transfer");
        }
    }
    
/*    public averageBalance(this){
        clientMax = len(this.client_database)
        totalBal = 0
        clientAvg = 0
        for i in range(clientMax){
            totalBal += this.client_database[i].getBalance()

        if(clientMax > 0){
            clientAvg = totalBal / clientMax

        return format(clientAvg, '2.2f')
*/
    public void generateReport(){
    	System.out.println("\nDevon's Bank Customer Report.");
    	System.out.println("Name  ID  Balance.");
    	System.out.println("=============================");
    	for(int i=0; i<client_database.size(); i++ ){
    		System.out.print(((Account)client_database.get(i)).getName() + " ");
        	System.out.print(((Account)client_database.get(i)).getId() + " ");
        	System.out.println(((Account)client_database.get(i)).getBalance());
        	/*System.out.println(String.format("10s", ((Account)client_database.get(i)).getName() + " aaa"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getId() + "bbb"));
        	System.out.println(String.format("10s", ((Account)client_database.get(i)).getBalance()));*/
        	//System.out.println("Average client balance is{", this.averageBalance());
    	}
    }

/*    public inputDatabase(this, filename){
        count = 1
        currentFilename = filename
        prefix = filename.split(".")[0]
        while(True){
            if(os.path.isfile(filename)){
                currentFilename = filename
                filename = prefix + str(count) + ".txt"
                count += 1
            else{
                break
        infile = open(currentFilename, 'r')
        line = infile.readline()
        count = 0
        while(line != ""){
            try{
                data = line.strip().split()
                if(data[0] == "@deposit"){
                    this.deposit(data[1], float(data[2]))
                elif (data[0] == "@withdraw"){
                    this.withdraw(data[1], float(data[2]))
                elif (data[0] == "@transfer"){
                    this.transfer(data[1], data[2], float(data[3]))
                else{
                    fname = data[0].strip()
                    lname = data[1].strip()
                    clientId = data[2].strip()
                    bal = float(data[3].strip())
                    newClient = Account(fname, lname, clientId, bal)
                    this.insert(newClient)
            except{
                count += 1
                print(count, data)
            line = infile.readline()
        
        infile.close()
        return True
*/
        
/*    public saveData(this){
        count = 1
        filename = "ClientDatabase.txt"
        while(True){
            if(os.path.isfile(filename)){
                filename = "ClientDatabase" + str(count) + ".txt"
                count += 1
            else{
                break
        outfile = open(filename, 'w')
        for i in range(len(this.client_database)){
            if(i > 0){
                 outfile.write("\n")
            outfile.write(this.client_database[i].getName() + " " + \
                          str(this.client_database[i].getId()) + " " + \
                          str(this.client_database[i].getBalance()))
        outfile.close()
        print("Client database saved to", filename)
        return filename
*/
}//end of class
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:188)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.makeConsistent(AJReconcileWorkingCopyOperation.java:244)
	at org.eclipse.ajdt.core.reconcile.AJReconcileWorkingCopyOperation.executeOperation(AJReconcileWorkingCopyOperation.java:121)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.reconcile(AJCompilationUnit.java:519)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 100
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.consumeNormalAnnotation(AJSourceElementParser2.java:569)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6538)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12016)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:12654)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12957)
	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12943)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:368)
	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:13063)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12083)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12369)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:198)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:951)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11052)
	at org.eclipse.ajdt.core.parserbridge.AJSourceElementParser2.parseCompilationUnit(AJSourceElementParser2.java:971)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:241)
	... 16 more
